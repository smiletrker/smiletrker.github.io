{"version":3,"sources":["img/test.jpg","views/Home.js","api/face.js","views/ImageInput.js","views/VideoInput.js","views/FrontPage.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","__webpack_require__","p","Component","loadModels","_loadModels","apply","this","arguments","_callee","MODEL_URL","regenerator_default","a","wrap","_context","prev","next","faceapi","stop","getFullFaceDescription","_x","_getFullFaceDescription","_callee2","blob","inputSize","OPTION","img","allFaces","fullDesc","vec","_args2","_context2","length","undefined","scoreThreshold","sent","withFaceExpressions","abrupt","maxDescriptorDistance","createMatcher","_x2","_createMatcher","_callee3","faceProfile","members","labeledDescriptors","faceMatcher","_context3","Object","keys","map","member","name","descriptors","descriptor","Float32Array","testImg","require","JSON_PROFILE","INIT_STATE","imageURL","detections","match","ImageInput","props","_this","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","componentWillMount","asyncToGenerator","mark","t0","t1","t2","setState","handleImage","state","image","then","fd","detection","findBestMatch","handleFileChange","_ref3","event","resetState","URL","createObjectURL","target","files","loading","objectSpread","_this$state","drawBox","i","_H","box","height","_W","width","_X","_Y","_y","react_default","createElement","key","style","position","border","borderColor","transform","concat","backgroundColor","marginTop","color","_label","id","type","onChange","accept","src","alt","withRouter","VideoInput","setInputDevice","navigator","mediaDevices","enumerateDevices","_ref2","devices","filter","device","kind","facingMode","exact","startCapture","interval","setInterval","capture","webcam","current","getScreenshot","vectors","distances","Math","min","push","error","console","log","newEmotion","expressions","sort","b","probability","newHappy","lastemotion","startSmiling","document","showSmiles","stopSmiling","smilecounter","React","createRef","clearInterval","videoConstraints","_expressioncolor","neutral","surprised","angry","sad","fearful","disgusted","happy","className","react_webcam_default","audio","ref","screenshotFormat","Home","smiling","createSmiles","smiles","emojis","emj","floor","random","j","smileStyle","left","window","innerWidth","top","innerHeight","class","views_VideoInput","App","HashRouter","history","createHistory","basename","process","Route","path","component","FrontPage","Boolean","location","hostname","ReactDOM","render","src_App_0","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.37145028.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/test.ccd20247.jpg\";","import React, { Component } from 'react';\nimport { Link } from 'react-router-dom';\n\nexport default class Home extends Component {\n  render() {\n    return (\n      <div>\n        <h2>Face Recognizer</h2>\n        \n        <li>\n          <Link to=\"/camera\">Video Camera</Link>\n        </li>\n      </div>\n    );\n  }\n}\n","import * as faceapi from 'face-api.js';\n//import sharp from 'sharp';\n\n// Load models and weights\nexport async function loadModels() {\n  const MODEL_URL = process.env.PUBLIC_URL + '/models';\n  await faceapi.loadTinyFaceDetectorModel(MODEL_URL);\n  await faceapi.loadFaceLandmarkTinyModel(MODEL_URL);\n  await faceapi.loadFaceExpressionModel(MODEL_URL);\n  await faceapi.loadFaceRecognitionModel(MODEL_URL);\n  //await faceapi.loadFaceLandmarkModel(MODEL_URL);\n}\n\nexport async function getFullFaceDescription(blob, inputSize = 512) {\n  // tiny_face_detector options\n  let scoreThreshold = 0.5;\n  const OPTION = new faceapi.TinyFaceDetectorOptions({\n    inputSize,\n    scoreThreshold\n  });\n  const useTinyModel = true;\n\n  // fetch image to api\n  let img = await faceapi.fetchImage(blob);\n\n  // detect all faces and generate full description from image\n  // including landmark and descriptor of each face\n  /*let fullDesc = await faceapi\n    .detectAllFaces(img, OPTION)\n    .withFaceLandmarks(useTinyModel)\n    .withFaceDescriptors()\n   // .withFaceExpressions()\n   */\n  const allFaces =  faceapi.detectAllFaces(img, OPTION)\n  //sharp()\n  //const fullDesc = await allFaces.withFaceLandmarks(useTinyModel).withFaceDescriptors()\n  //const fullDesc = await faceapi.detectAllFaces(img, OPTION).withFaceExpressions()\n  const fullDesc = await allFaces.withFaceExpressions()\n  //console.log((await allFaces.withFaceLandmarks()))\n  let vec = await faceapi.computeFaceDescriptor(img)\n  fullDesc['vector'] = vec\n//  console.log(vec)\n  //let box = fullDesc[0] ?fullDesc[0]['detection']['_box'] : false;\n  //console.log(box)\n  return fullDesc;//fullDesc;\n}\n// face.js code...\n\nconst maxDescriptorDistance = 0.5;\nexport async function createMatcher(faceProfile) {\n  // Create labeled descriptors of member from profile\n  let members = Object.keys(faceProfile);\n  let labeledDescriptors = members.map(\n    member =>\n      new faceapi.LabeledFaceDescriptors(\n        faceProfile[member].name,\n        faceProfile[member].descriptors.map(\n          descriptor => new Float32Array(descriptor)\n        )\n      )\n  );\n\n  // Create face matcher (maximum descriptor distance is 0.5)\n  let faceMatcher = new faceapi.FaceMatcher(\n    labeledDescriptors,\n    maxDescriptorDistance\n  );\n  return faceMatcher;\n}\n","import React, { Component } from 'react';\nimport { withRouter } from 'react-router-dom';\nimport { loadModels, getFullFaceDescription, createMatcher } from '../api/face';\n\n// Import image to test API\nconst testImg = require('../img/test.jpg');\n\n// Import face profile\nconst JSON_PROFILE = require('../descriptors/bnk48.json');\n\n// Initial State\nconst INIT_STATE = {\n  imageURL: testImg,\n  fullDesc: null,\n  detections: null,\n  descriptors: null,\n  match: null\n};\n\nclass ImageInput extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { ...INIT_STATE, faceMatcher: null };\n  }\n\n  componentWillMount = async () => {\n    await loadModels();\n    this.setState({ faceMatcher: await createMatcher(JSON_PROFILE) });\n    await this.handleImage(this.state.imageURL);\n  };\n\n  handleImage = async (image = this.state.imageURL) => {\n    await getFullFaceDescription(image).then(fullDesc => {\n      if (!!fullDesc) {\n        this.setState({\n          fullDesc,\n          detections: fullDesc.map(fd => fd.detection),\n         // descriptors: fullDesc.map(fd => fd.descriptor)\n        });\n      }\n    });\n\n    if (!!this.state.descriptors && !!this.state.faceMatcher) {\n      let match = await this.state.descriptors.map(descriptor =>\n        this.state.faceMatcher.findBestMatch(descriptor)\n      );\n      this.setState({ match });\n    }\n  };\n\n  handleFileChange = async event => {\n    this.resetState();\n    await this.setState({\n      imageURL: URL.createObjectURL(event.target.files[0]),\n      loading: true\n    });\n    this.handleImage();\n  };\n\n  resetState = () => {\n    this.setState({ ...INIT_STATE });\n  };\n\n  render() {\n    const { imageURL, detections, match } = this.state;\n\n    let drawBox = null;\n    if (!!detections) {\n      drawBox = detections.map((detection, i) => {\n        let _H = detection.box.height;\n        let _W = detection.box.width;\n        let _X = detection.box._x;\n        let _Y = detection.box._y;\n        return (\n          <div key={i}>\n            <div\n              style={{\n                position: 'absolute',\n                border: 'solid',\n                borderColor: 'green',\n                height: _H,\n                width: _W,\n                transform: `translate(${_X}px,${_Y}px)`\n              }}\n            >\n              {!!match && !!match[i] ? (\n                <p\n                  style={{\n                    backgroundColor: 'green',\n                    border: 'solid',\n                    borderColor: 'green',\n                    width: _W,\n                    marginTop: 0,\n                    color: '#fff',\n                    transform: `translate(-3px,${_H}px)`\n                  }}\n                >\n                  {match[i]._label}\n                </p>\n              ) : null}\n            </div>\n          </div>\n        );\n      });\n    }\n\n    return (\n      <div>\n        <input\n          id=\"myFileUpload\"\n          type=\"file\"\n          onChange={this.handleFileChange}\n          accept=\".jpg, .jpeg, .png\"\n        />\n        <div style={{ position: 'relative' }}>\n          <div style={{ position: 'absolute' }}>\n            <img src={imageURL} alt=\"imageURL\" />\n          </div>\n          {!!drawBox ? drawBox : null}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default withRouter(ImageInput);\n","import React, { Component } from 'react';\nimport { withRouter } from 'react-router-dom';\nimport Webcam from 'react-webcam';\nimport { loadModels, getFullFaceDescription, createMatcher } from '../api/face';\nimport * as faceapi from 'face-api.js';\nimport './../smile.scss';\n\n\n// Import face profile\nconst JSON_PROFILE = require('../descriptors/bnk48.json');\n\nconst WIDTH = 420;\nconst HEIGHT = 420;\nconst inputSize = 160;\n\nclass VideoInput extends Component {\n  constructor(props) {\n    super(props);\n    this.webcam = React.createRef();\n    this.state = {\n      fullDesc: null,\n      detections: null,\n      descriptors: null,\n      faceMatcher: null,\n      match: null,\n      lastemotion: null,\n      smilecounter: 0,\n      facingMode: 'user'\n    };\n  }\n\n  componentWillMount = async () => {\n    await loadModels();\n    this.setState({ faceMatcher: await createMatcher(JSON_PROFILE) });\n    this.setInputDevice();\n  };\n\n  setInputDevice = () => {\n    navigator.mediaDevices.enumerateDevices().then(async devices => {\n      let inputDevice = await devices.filter(\n        device => device.kind === 'videoinput'\n      );\n      if (inputDevice.length < 2) {\n        await this.setState({\n          facingMode: 'user'\n        });\n      } else {\n        await this.setState({\n          facingMode: { exact: 'environment' }\n        });\n      }\n      this.startCapture();\n    });\n  };\n\n  startCapture = () => {\n    this.interval = setInterval(() => {\n      this.capture();\n    }, 200);\n  };\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  capture = async () => {\n    if (!!this.webcam.current) {\n      await getFullFaceDescription(\n        this.webcam.current.getScreenshot(),\n        inputSize\n      ).then(fullDesc => {\n        if (!!fullDesc) {\n          // console.log(fullDesc)\n          //const = fullDesc.sort(function(a, b){return a.expressions - b})\n          let vectors\n          try {\n            vectors = this.state.vectors\n            let distances = vectors.map(vec => {\n\n              let distance = faceapi.euclideanDistance(vec, fullDesc['vector'])\n              return distance\n            })\n            let minDistance = Math.min(distances)\n            if (minDistance > 0.5) {\n              vectors.push(fullDesc['vector'])\n            }\n\n          } catch (error) {\n            console.log(error)\n            vectors = [fullDesc['vector']]\n          }\n          let expressions = fullDesc.map(fd => {\n            // Sort expressions by probability :)\n            let expressions = fd.expressions\n            expressions.sort(function (a, b) { return b.probability - a.probability })\n            return expressions\n          })\n\n          let newEmotion\n          let newHappy = 0\n          try {\n            newEmotion = expressions[0][0]['expression']\n            if (this.state.lastemotion !== \"happy\") {\n              if (newEmotion === 'happy') {\n                newHappy = 1;\n                this.props.startSmiling();\n                document.showSmiles();\n              }\n            } else if (newEmotion !== 'happy') {\n              this.props.stopSmiling();\n            }\n          } catch (error) {\n\n          }\n          this.setState({\n            vectors: vectors,\n            detections: fullDesc.map(fd => fd.detection),\n            descriptors: expressions,\n            lastemotion: newEmotion,\n            smilecounter: this.state.smilecounter + newHappy\n            //vectors: fullDesc.map(fd => fd.detection)\n          });\n        }\n      });\n\n      if (!!this.state.descriptors && !!this.state.faceMatcher) {\n        //  console.log(this.state.descriptors)\n        // let match = await this.state.descriptors.map(descriptor =>\n        //   this.state.faceMatcher.findBestMatch(descriptor)\n        // );\n        // this.setState({ match });\n      }\n    }\n  };\n\n  render() {\n    const { detections, match, facingMode, descriptors } = this.state;\n    let videoConstraints = null;\n    let camera = '';\n    if (!!facingMode) {\n      videoConstraints = {\n        width: WIDTH,\n        height: HEIGHT,\n        facingMode: facingMode\n      };\n      if (facingMode === 'user') {\n        camera = 'Front';\n      } else {\n        camera = 'Back';\n      }\n    }\n\n    let drawBox = null;\n    if (!!detections) {\n      drawBox = detections.map((detection, i) => {\n        let _H = detection.box.height;\n        let _W = detection.box.width;\n        let _X = detection.box._x;\n        let _Y = detection.box._y;\n        let _expressioncolor = 'black'\n        try {\n          let colormap = { 'neutral': 'white', 'surprised': 'white', 'angry': 'red', 'sad': 'red', 'fearful': 'red', 'disgusted': 'white', \"happy\": \"#4CCEB1\" }\n          //console.log(descriptors[i])\n          let _expression = descriptors[i][0]['expression']\n          _expressioncolor = colormap[_expression]\n          //console.log(_expressioncolor)\n        } catch (error) {\n          console.log(error)\n        }\n\n        return (\n          <div key={i}>\n            <div\n              style={{\n                position: 'absolute',\n                border: 'solid',\n                borderColor: _expressioncolor,\n                //boxShadow: \"-10px 0 40px #7CDBC9 10px 0 40px #E0F0CF;\",\n                height: _H,\n                width: _W,\n                //borderRadius: '500px',\n                transform: `translate(${_X}px,${_Y}px)`\n              }}\n            >\n              {!!match && !!match[i] ? (\n                <p\n                  style={{\n                    backgroundColor: 'blue',\n                    border: 'solid',\n                    borderColor: 'blue',\n                    width: _W,\n                    marginTop: 0,\n                    color: '#fff',\n                    transform: `translate(-3px,${_H}px)`\n                  }}\n                >\n                  {match[i]._label}\n                </p>\n              ) : null}\n            </div>\n          </div>\n        );\n      });\n    }\n\n    return (\n      <div className=\"Camera\">\n        <div\n          style={{\n            width: WIDTH,\n            height: HEIGHT\n          }}\n        >\n          <div style={{ position: 'relative', width: WIDTH }}>\n            {!!videoConstraints ? (\n              <div style={{ position: 'absolute' }}>\n                <Webcam\n                  audio={false}\n                  width={WIDTH}\n                  height={HEIGHT}\n                  ref={this.webcam}\n                  screenshotFormat=\"image/jpeg\"\n                  videoConstraints={videoConstraints}\n                />\n              </div>\n            ) : null}\n            {!!drawBox ? drawBox : null}\n          </div>\n\n        </div>\n        {/* <div>\n          {this.state.vectors ? this.state.vectors.length : \"\"}\n        </div> */}\n\n        {/*JSON.stringify(this.state.descriptors)*/}\n\n      </div>\n\n    );\n  }\n}\n\nexport default withRouter(VideoInput);\n","import VideoInput from './VideoInput';\nimport React, {Component} from 'react';\nimport {Link} from 'react-router-dom';\n\nexport default class Home extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {smilecounter: 0}\n\n  }\n\n  startSmiling = () => {\n    this.setState({\n      smilecounter: this.state.smilecounter + 1,\n      smiling: true\n    })\n  }\n\n  stopSmiling = () => {\n    this.setState({\n      smilecounter: this.state.smilecounter,\n      smiling: false\n    })\n  }\n\n  createSmiles = () => {\n    if(!this.state.smiling){\n      return;\n    }\n    let smiles = []\n    const emojis = [\"üòÅ\", \"üòç\", \"üëç\", \"üòÖ\", \"ü§©\", \"üòú\", \"üò¨\", \"ü§†\", \"üò∏\", \"üòª\", \"üí©\"];\n    var emj = emojis[Math.floor(Math.random() * emojis.length)];\n    for (let j = 0; j < 50; j++) {\n      const smileStyle = {\n        position: \"absolute\",\n        left: Math.random() * window.innerWidth + \"px\",\n        top: Math.random() * window.innerHeight + \"px\",\n      };\n      smiles.push(<div class=\"smile_transform visible_smile\" id={\"smile_\" + j} style={smileStyle}>{emj}</div>)\n    }\n    return smiles\n  }\n\n  render() {\n    return (\n      <div>\n        <div class=\"canvas\">\n          <div className=\"info-text\">Max smiles per day ‚Äì 247</div>\n          <VideoInput startSmiling={this.startSmiling} stopSmiling={this.stopSmiling}/>\n          <div class={\"counter-panel boxed \" + (this.state.smiling ? \"counter-panel-animation\" : \"scaled\")}>\n            <div id=\"timesClicked\" class=\"number\">{this.state.smilecounter}</div>\n            <div class=\"item-wrapper\">\n              <div class=\"item\">smiles</div>\n              <div class=\"item\">today</div>\n            </div>\n          </div>\n\n          {this.createSmiles()}\n        </div>\n\n      </div>\n\n\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { Route, HashRouter } from 'react-router-dom';\nimport createHistory from 'history/createBrowserHistory';\nimport './App.css';\n\nimport Home from './views/Home';\nimport ImageInput from './views/ImageInput';\nimport FrontPage from './views/FrontPage';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <HashRouter history={createHistory({ basename: process.env.PUBLIC_URL })}>\n          <div className=\"route\">\n            <Route exact path=\"/\" component={FrontPage} />\n            <Route exact path=\"/upload\" component={ImageInput} />\n          </div>\n        </HashRouter>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}